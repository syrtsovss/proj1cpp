#include <SFML/Graphics/RenderWindow.hpp>
#include <SFML/System/Clock.hpp>
#include <SFML/Window/Event.hpp>

#include <imgui-SFML.h>
#include <imgui.h>

// первое множество
static const int SET_1 = 0;
// второе множество
static const int SET_2 = 1;
// пересечение множеств
static const int SET_CROSSED = 2;
// разность множеств
static const int SET_SINGLE = 3;

// Ўирина окна
static const int WINDOW_SIZE_X = 800;
// ¬ысота окна
static const int WINDOW_SIZE_Y = 800;

// “очка
struct Point {
    // положение
    sf::Vector2i pos;
    // номер множества
    int setNum;

    // конструктор
    Point(const sf::Vector2i& pos, int setNum) : pos(pos), setNum(setNum) {
    }
};

// динамический список точек
std::vector<Point> points;

// цвет фона
static sf::Color bgColor;
// значение цвета по умолчанию
float color[3] = { 0.12f, 0.12f, 0.13f };

// задать цвет фона по вещественному массиву компонент
static void setColor(float* pDouble) {
    bgColor.r = static_cast<sf::Uint8>(pDouble[0] * 255.f);
    bgColor.g = static_cast<sf::Uint8>(pDouble[1] * 255.f);
    bgColor.b = static_cast<sf::Uint8>(pDouble[2] * 255.f);
}

// рисование параметров цвета
void ShowBackgroundSetting() {
    // »нструмент выбора цвета
    if (ImGui::ColorEdit3("Background color", color)) {
        // код вызываетс€ при изменении значени€
        // задаЄм цвет фона
        setColor(color);
    }
    // конец рисование окна
}


// рисование задачи на невидимом окне во всЄ окно приложени€
void RenderTask() {
    // задаЄм левый верхний край невидимого окна
    ImGui::SetNextWindowPos(ImVec2(0, 0));
    // задаЄм правый нижний край невидимого окна
    ImGui::SetNextWindowSize(ImVec2(WINDOW_SIZE_X, WINDOW_SIZE_Y));
    // создаЄм невидимое окно
    ImGui::Begin("Overlay", nullptr,
        ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove |
        ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoBackground);
    // получаем список примитивов, которые будут нарисованы
    auto pDrawList = ImGui::GetWindowDrawList();

    // перебираем точки из динамического массива точек
    for (auto point : points) {
        // добавл€ем в список рисовани€ круг
        pDrawList->AddCircleFilled(
            sf::Vector2i(point.pos.x, point.pos.y),
            3,
            point.setNum == SET_1 ? ImColor(200, 100, 150) : ImColor(100, 200, 150),
            20
        );
    }
    // заканчиваем рисование окна
    ImGui::End();
}

// главный метод
int main() {
    // создаЄм окно дл€ рисовани€
    sf::RenderWindow window(sf::VideoMode(WINDOW_SIZE_X, WINDOW_SIZE_Y), "Geometry Project 10");
    // задаЄм частоту перерисовки окна
    window.setFramerateLimit(60);
    // инициализаци€ imgui+sfml
    ImGui::SFML::Init(window);

    // задаЄм цвет фона
    setColor(color);

    points.push_back(Point(sf::Vector2i(100, 600), SET_1));
    points.push_back(Point(sf::Vector2i(100, 700), SET_1));
    points.push_back(Point(sf::Vector2i(200, 500), SET_2));
    points.push_back(Point(sf::Vector2i(200, 700), SET_2));

    // переменна€ таймера
    sf::Clock deltaClock;
    // пока окно открыто, запускаем бесконечный цикл
    while (window.isOpen()) {
        // создаЄм событие sfml
        sf::Event event;
        // пока окно принимает событи€
        while (window.pollEvent(event)) {
            // отправл€ем событи€ на обработку sfml
            ImGui::SFML::ProcessEvent(event);

            // если событие - это клик мышью
            if ((event.type == sf::Event::MouseButtonPressed) && (!ImGui::GetIO().WantCaptureMouse)) {
                // если лева€ кнопка мыши
                if (event.mouseButton.button == sf::Mouse::Button::Left)
                    points.emplace_back(sf::Vector2i(event.mouseButton.x, event.mouseButton.y), SET_1);
                else
                    points.emplace_back(sf::Vector2i(event.mouseButton.x, event.mouseButton.y), SET_2);
            }

            // если событие - это закрытие окна
            if (event.type == sf::Event::Closed) {
                // закрываем окно
                window.close();
            }
        }

        // запускаем обновление окна по таймеру с заданной частотой
        ImGui::SFML::Update(window, deltaClock.restart());

        // рисование задани€
        RenderTask();

        // делаем окно полупрозрачным
        ImGui::PushStyleColor(ImGuiCol_WindowBg, ImVec4(0.12f, 0.12f, 0.13f, 0.8f));

        // создаЄм окно управлени€
        ImGui::Begin("Control");

        // рисование параметров цвета
        ShowBackgroundSetting();

        // конец рисовани€ окна
        ImGui::End();

        // ¬озвращаем цвет окна к исходному
        ImGui::PopStyleColor();

        // очищаем окно
        window.clear(bgColor);
        // рисуем по окну средствами imgui+sfml
        ImGui::SFML::Render(window);
        // отображаем изменени€ на окне
        window.display();
    }

    // завершаем работу imgui+sfml
    ImGui::SFML::Shutdown();

    return 0;
}